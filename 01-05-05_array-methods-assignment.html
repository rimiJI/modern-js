<!--함수-메서드 과제 10/13 ...진행중...  -->
<head></head>
<body>
  <script>
    //1🍅 -들어간 문자 변경하기
    function camelize(str) {
      //split으로 배열[]로 만든 다음
      //map을 사용해 첫 번째 요소를 제외한 나머지 요소들의 첫 글자를 대문자로 변경합니다.
      //join으로 배열을 다시 문자열로 합칩니다.
      return str //'list-style-image'
        .split("-") //['list','style','image']
        .map((word, index) =>
          index == 0 ? word : word[0].toUpperCase() + word.slice(1)
        ) //['list','Style','Image']
        .join(""); //listStyleImage
    }
    console.log(camelize("background-color"));
    console.log(camelize("list-style-image"));
    console.log(camelize("-webkit-transition"));

    //🎁HINT
    //let result = arr.map(function(item, index, array) {
    //   // 요소 대신 새로운 값을 반환합니다.
    // });
    //

    //2🍎특정 범위에 속하는 요소 찾기
    function filterRange(arr, a, b) {
      // a <= item <= b 와 같은 체이닝 비교는 JavaScript에서 의도한 대로 동작하지 않습니다.
      // (a <= item)이 먼저 평가되어 true/false가 되고, 그 결과가 b와 비교되기 때문입니다.
      return arr.filter((item) => a <= item && item <= b);
    }
    let arr = [5, 3, 8, 1];

    let filtered = filterRange(arr, 1, 4);
    console.log(`특정요소찾기함수실행후 filtered: ${filtered}`); // 3,1 (조건에 맞는 요소)
    console.log(`기존배열 변경안됨 arr: ${arr}`); // 5,3,8,1 (기존 배열은 변경되지 않았습니다.)

    // 🎁특정 값을 만족하는 값을 뽑아내는 함수는
    //filter

    //3🍎배열 arr의 요소 중 a와 b 사이에 속하지 않는 요소는 삭제해주는 함수
    let case1 = [5, 3, 8, 1];
    let case2 = [1, 5, 8, 2];

    function filterRangeInPlace(arr, a, b) {
      for (let i = 0; i < arr.length; i++) {
        //.length를 .lenght 라고 오타
        if (arr[i] < a || b < arr[i]) {
          //❌delete 하면 값 변동 있긴 한데 빈 값이 생겨버림 [,3,,1]
          // delete arr[i];
          //⭕이 과제에서 배운 splice 이용
          arr.splice(i, 1);
          //이렇게 삭제했으니깐 순번 i도 꼭 한걸음 뒤로 물러나줘야함
          // arr = [A1, A2, A3, A4, A5] // arr= [A1, A2, **A4**, **A5**]
          i--;
          // ⭐splice로 현재 i번째 요소를 제거하면,
          // i+1번째에 있던 요소가 새로운 i번째 요소가 됩니다.
          // 이때 i--를 통해 인덱스를 한 칸 뒤로 물러나게 한 뒤,
          // 루프의 i++가 다시 인덱스를 i로 만들어 줌으로써,
          // 새롭게 이사 온 요소를 놓치지 않고 다시 검사할 수 있게 되는 것
        }
      }
    }
    filterRangeInPlace(case1, 1, 4);
    filterRangeInPlace(case2, 1, 4);
    console.log(`배열요소 사이값아니면 삭제하는 함수 ${case1}`);
    console.log(`배열요소 사이값아니면 삭제하는 함수 ${case2}`);
    // 🎁배열에서 요소 하나만 지우고 싶다면?
    // splice
    //splice(여기부터,몇개를,[대체하고싶은값들~])

    //4🍎내림차순으로 정렬
    arr = [5, 2, 1, -10, 8];
    arr.sort((a, b) => b - a);
    console.log(arr); // 8, 5, 2, 1, -10
    //🎁...hint sort( a,b=>b-a)
    /*
    sort(a,b) 규칙
    ❗a: 비교할 첫 번째 요소
    ❗b: 비교할 두 번째 요소
    우리의 역할은 그 약속에 맞춰
    두 요소를 비교하는 로직(a - b 또는 b - a)을 작성해 반환하는 것

    b - a는 어떻게 동작하나요?
    비교 함수는 다음 규칙에 따라 숫자 값을 반환해야 합니다.

    반환값이 0보다 크면: b를 a보다 앞 순서로 보냅니다. (내림차순)
    반환값이 0보다 작으면: a를 b보다 앞 순서로 보냅니다. (오름차순)
    반환값이 0이면: 순서를 바꾸지 않습니다.
    b - a 규칙을 적용해 봅시다.

    만약 a가 3, b가 8이라면: b - a는 8 - 3 = 5 (0보다 큼) -> 8이 3보다 앞에 와야 합니다.
    만약 a가 10, b가 4이라면: b - a는 4 - 10 = -6 (0보다 작음) -> 10이 4보다 앞에 와야 합니다.
    결과적으로 더 큰 숫자가 항상 앞으로 오게 되므로 배열은 **내림차순(큰 수부터 작은 수 순서)**으로 정렬됩니다.*/

    //5🍎배열 복사본 정렬
    //sort( (a, b) => a.localeCompare(b) )
    function copySorted(arr) {
      return arr.slice().sort((a, b) => a.localeCompare(b));
    }

    arr = ["HTML", "JavaScript", "CSS"];
    let sorted = copySorted(arr);
    console.log(sorted); // CSS, HTML, JavaScript
    console.log(arr); // HTML, JavaScript, CSS (no changes)

    //7🍎이름 매핑하기 ; 객체이름을 뽑아서 배열어레이로 만들기
    //프로퍼티 객체 {:}가 있는데, name값만 담은 새로운 배열을 만드시오
    let john = { name: "John", age: 25 };
    let pete = { name: "Pete", age: 30 };
    let mary = { name: "Mary", age: 28 };
    let users = [john, pete, mary];

    let names = users.map((item) => item.name);

    console.log(`객체프로퍼티이름을 배열에 저장시키기 ${names}`); // John, Pete, Mary
    //     🎁Hint
    // ... .map(function(item, index, array)
    // ... .map(item => item.length);

    //9🍎🚧객체 매핑하기
    //원하는바
    // {name:~ ,surname:~ ,id:~ };
    // {fullname:~ , id:~ }
    john = { name: "John", surname: "Smith", id: 1 };
    pete = { name: "Pete", surname: "Hunt", id: 2 };
    mary = { name: "Mary", surname: "Key", id: 3 };

    users = [john, pete, mary];

    let usersMapped = users.map((u) => ({
      fullName: `${u.name} ${u.surname}`,
      id: u.id,
    }));
    /*
      usersMapped = [
        { fullName: "John Smith", id: 1 },
        { fullName: "Pete Hunt", id: 2 },
        { fullName: "Mary Key", id: 3 }
      ]
      */
    console.log(usersMapped[0].id); // 1
    console.log(usersMapped[0].fullName); // John Smith

    //10🍎나이를 기준으로 객체 정렬
    //sort이긴 한데 , 객체 프로퍼티에 접근하는 것을 생각해야함.
    //오름차순 a-b, 내림차순 b-a
    //지금은 오름차순
    john = { name: "John", age: 25 };
    pete = { name: "Pete", age: 30 };
    mary = { name: "Mary", age: 28 };
    arr = [pete, john, mary];

    function sortByAge(age) {
      arr.sort((a, b) => a.age - b.age);
    }

    sortByAge(arr);
    // arr = [john, mary, pete] (크게보면 배열이지만 안에는 객체들이 쏙쏙 들어있는 형태
    // 즉, 순서가 있는 객체의 묶음이라고 볼 수 있다. )
    console.log(arr); // 나이순으로 정렬되어있는 것을 볼 수 있다.

    //11🍎무작위로 배열 섞는 함수 (어렵..네? 😊)

    //12🍎평균나이 구하기
    //배열을 기반으로 한가지 값을 도출할땐 reduce! (<>맵은 각각 함수 적용해서 값을 변환시키는 거지만.)
    //reduce(func, initial) – 요소를 차례로 돌면서 func을 호출함. 반환값은 다음 함수 호출에 전달함. 최종적으로 하나의 값이 도출됨
    //reduce 예제에선 누산기가 있었음
    //
    john = { name: "John", age: 25 };
    pete = { name: "Pete", age: 30 };
    mary = { name: "Mary", age: 29 };
    arr = [john, pete, mary];

    // 원본에서 값돌아가면서 값을 수집한다음, / 배열의길이(갯수)로 나누면됨
    //새로울 값 = arr.reduce((sum, currunt)=>sum+currunt, 0)
    // (여기서 0은 마지막인수인 하나남은 인덱스넘버))
    function getAverageAge(user) {
      return user.reduce((sum, c) => sum + c.age, 0) / user.length;
    }
    console.log(getAverageAge(arr)); // (25 + 30 + 29) / 3 = 28

    //13🍎중복 없는 요소 찾아내기
    //일단 새 배열에 푸쉬하고, 하나씩 뽑아내며 push하고,
    //만약 중독되는 값이 있으면 if의 조건에 해당되지 않으니까 push가 ❌
    //output 배열을 '이미 입장한 손님 명단' 이라고 생각하면 아주 쉬워요
    function unique(arr) {
      /* your code */
      let output = [];
      for (let item of arr) {
        if (!output.includes(item)) {
          output.push(item);
        }
      }
      return output; //함수가 끝날 때 그 결과물을 밖으로 전달해주는 '출구'
    }

    let strings = [
      "Hare",
      "Krishna",
      "Hare",
      "Krishna",
      "Krishna",
      "Krishna",
      "Hare",
      "Hare",
      ":-O",
    ];

    console.log(unique(strings)); // Hare, Krishna, :-O

    // ✨ 더 현대적이고 간결한 방법: Set
    function uniqueWithSet(arr) {
      // 1. 배열(arr)을 Set으로 만들어서 중복을 자동으로 제거
      // 2. Set을 다시 배열로 변환하기 위해 스프레드 문법(...)을 사용
      return [...new Set(arr)];
      //[...new Set(arr)] 이 문법은 코드를 매우 간결하고 읽기 쉽게,배열의 중복을 제거할 때 가장 널리 사용되는 방법 중 하나
      // Set(arr) ▶{ 'Hare', 'Krishna', ':-O' }
      // ... (전개 구문, Spread Syntax) - 주머니 속 내용물 펼치기, 값 목록이 됨 ▶'Hare', 'Krishna', ':-O'
      //[ ] ▶배열에 담기.[ 'Hare', 'Krishna', ':-O' ]
    }
    console.log("Set을 사용한 결과:", uniqueWithSet(strings)); // ["Hare", "Krishna", ":-O"]
  </script>
</body>
