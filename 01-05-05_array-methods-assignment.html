<!--함수-메서드 과제 7/13 ...진행중...  -->
<head></head>
<body>
  <script>
    //1🍅 -들어간 문자 변경하기
    function camelize(str) {
      //split으로 배열[]로 만든 다음
      //map을 사용해 첫 번째 요소를 제외한 나머지 요소들의 첫 글자를 대문자로 변경합니다.
      //join으로 배열을 다시 문자열로 합칩니다.
      return str //'list-style-image'
        .split("-") //['list','style','image']
        .map((word, index) =>
          index == 0 ? word : word[0].toUpperCase() + word.slice(1)
        ) //['list','Style','Image']
        .join(""); //listStyleImage
    }
    console.log(camelize("background-color"));
    console.log(camelize("list-style-image"));
    console.log(camelize("-webkit-transition"));

    //🎁HINT
    //let result = arr.map(function(item, index, array) {
    //   // 요소 대신 새로운 값을 반환합니다.
    // });
    //

    //2🍎특정 범위에 속하는 요소 찾기
    function filterRange(arr, a, b) {
      // a <= item <= b 와 같은 체이닝 비교는 JavaScript에서 의도한 대로 동작하지 않습니다.
      // (a <= item)이 먼저 평가되어 true/false가 되고, 그 결과가 b와 비교되기 때문입니다.
      return arr.filter((item) => a <= item && item <= b);
    }
    let arr = [5, 3, 8, 1];

    let filtered = filterRange(arr, 1, 4);
    console.log(`특정요소찾기함수실행후 filtered: ${filtered}`); // 3,1 (조건에 맞는 요소)
    console.log(`기존배열 변경안됨 arr: ${arr}`); // 5,3,8,1 (기존 배열은 변경되지 않았습니다.)

    // 🎁특정 값을 만족하는 값을 뽑아내는 함수는
    //filter

    //3🍎배열 arr의 요소 중 a와 b 사이에 속하지 않는 요소는 삭제해주는 함수
    let case1 = [5, 3, 8, 1];
    let case2 = [1, 5, 8, 2];

    function filterRangeInPlace(arr, a, b) {
      for (let i = 0; i < arr.length; i++) {
        //.length를 .lenght 라고 오타
        if (arr[i] < a || b < arr[i]) {
          //❌delete 하면 값 변동 있긴 한데 빈 값이 생겨버림 [,3,,1]
          // delete arr[i];
          //⭕이 과제에서 배운 splice 이용
          arr.splice(i, 1);
          //이렇게 삭제했으니깐 순번 i도 꼭 한걸음 뒤로 물러나줘야함
          // arr = [A1, A2, A3, A4, A5] // arr= [A1, A2, **A4**, **A5**]
          i--;
          // ⭐splice로 현재 i번째 요소를 제거하면,
          // i+1번째에 있던 요소가 새로운 i번째 요소가 됩니다.
          // 이때 i--를 통해 인덱스를 한 칸 뒤로 물러나게 한 뒤,
          // 루프의 i++가 다시 인덱스를 i로 만들어 줌으로써,
          // 새롭게 이사 온 요소를 놓치지 않고 다시 검사할 수 있게 되는 것
        }
      }
    }
    filterRangeInPlace(case1, 1, 4);
    filterRangeInPlace(case2, 1, 4);
    console.log(`배열요소 사이값아니면 삭제하는 함수 ${case1}`);
    console.log(`배열요소 사이값아니면 삭제하는 함수 ${case2}`);
    // 🎁배열에서 요소 하나만 지우고 싶다면?
    // splice
    //splice(여기부터,몇개를,[대체하고싶은값들~])

    //4🍎내림차순으로 정렬
    arr = [5, 2, 1, -10, 8];
    arr.sort((a, b) => b - a);
    console.log(arr); // 8, 5, 2, 1, -10
    //🎁...hint sort( a,b=>b-a)
    /* 
    sort(a,b) 규칙
    ❗a: 비교할 첫 번째 요소
    ❗b: 비교할 두 번째 요소
    우리의 역할은 그 약속에 맞춰 
    두 요소를 비교하는 로직(a - b 또는 b - a)을 작성해 반환하는 것

    b - a는 어떻게 동작하나요?
    비교 함수는 다음 규칙에 따라 숫자 값을 반환해야 합니다.

    반환값이 0보다 크면: b를 a보다 앞 순서로 보냅니다. (내림차순)
    반환값이 0보다 작으면: a를 b보다 앞 순서로 보냅니다. (오름차순)
    반환값이 0이면: 순서를 바꾸지 않습니다.
    b - a 규칙을 적용해 봅시다.

    만약 a가 3, b가 8이라면: b - a는 8 - 3 = 5 (0보다 큼) -> 8이 3보다 앞에 와야 합니다.
    만약 a가 10, b가 4이라면: b - a는 4 - 10 = -6 (0보다 작음) -> 10이 4보다 앞에 와야 합니다.
    결과적으로 더 큰 숫자가 항상 앞으로 오게 되므로 배열은 **내림차순(큰 수부터 작은 수 순서)**으로 정렬됩니다.*/

    //5🍎배열 복사본 정렬
    //sort( (a, b) => a.localeCompare(b) )
    function copySorted(arr) {
      return arr.slice().sort((a, b) => a.localeCompare(b));
    }

    arr = ["HTML", "JavaScript", "CSS"];
    let sorted = copySorted(arr);
    console.log(sorted); // CSS, HTML, JavaScript
    console.log(arr); // HTML, JavaScript, CSS (no changes)

    //7🍎이름 매핑하기 ; 객체이름을 뽑아서 배열어레이로 만들기
    //프로퍼티 객체 {:}가 있는데, name값만 담은 새로운 배열을 만드시오
    let john = { name: "John", age: 25 };
    let pete = { name: "Pete", age: 30 };
    let mary = { name: "Mary", age: 28 };
    let users = [john, pete, mary];

    let names = users.map((item) => item.name);

    console.log(`객체프로퍼티이름을 배열에 저장시키기 ${names}`); // John, Pete, Mary
    //     🎁Hint
    // ... .map(function(item, index, array)
    // ... .map(item => item.length);

    //🍎🚧객체 매핑하기
    //원하는바
    // {name:~ ,surname:~ ,id:~ };
    // {fullname:~ , id:~ }
    john = { name: "John", surname: "Smith", id: 1 };
    pete = { name: "Pete", surname: "Hunt", id: 2 };
    mary = { name: "Mary", surname: "Key", id: 3 };

    users = [john, pete, mary];

    let usersMapped = users.map((u) => ({
      fullName: `${u.name} ${u.surname}`,
      id: u.id,
    }));
    /*
      usersMapped = [
        { fullName: "John Smith", id: 1 },
        { fullName: "Pete Hunt", id: 2 },
        { fullName: "Mary Key", id: 3 }
      ]
      */
    console.log(usersMapped[0].id); // 1
    console.log(usersMapped[0].fullName); // John Smith
  </script>
</body>
