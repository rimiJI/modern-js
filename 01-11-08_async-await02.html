<!-- 예제 1번 진행 -->
<head></head>
<body>
  <script>
    //🍎async와 await를 사용하여 코드 변경하기
    /*
    // [잘못된 예제 - 리캡용]
    // 문제점:
    // 1. try...catch가 함수 내부에 있어, 에러가 발생해도 함수 밖에서는 알 수 없습니다.
    // 2. response.status가 200이 아닌 경우(예: 404 Not Found)에 대한 처리가 없습니다.
    async function loadJson(url) {
      try {
        let response = await fetch(url);
        if (response.status == 200) {
          let json = await response.json();
          return json;
        }
      } catch (err) {
        // 네트워크 에러만 여기서 잡히고, 함수는 undefined를 반환하고 조용히 종료됩니다.
        console.log(err);
        console.error(err);
      }
    }
    // 함수를 호출만 하고 반환된 Promise나 에러를 처리하지 않아,
    // 성공해도, 실패해도 아무런 후속 조치가 없습니다.
    loadJson("no-such-user.json");
    */

    // [수정된 예제]
    // 개선점:
    // 1. 함수는 데이터 로딩에만 집중하고, 에러 처리는 호출한 쪽으로 위임합니다.
    // 2. HTTP 상태 에러(404 등)를 명시적으로 처리합니다.
    async function loadJson(url) {
      // fetch 요청을 보내고 응답을 기다립니다.
      let response = await fetch(url);

      // 응답 상태가 200 (성공)이면, json 본문을 파싱하여 반환합니다.
      if (response.status == 200) {
        // response.json()도 Promise를 반환하므로, async 함수는 이 Promise를 그대로 반환합니다.
        return response.json();
      }

      // 응답 상태가 200이 아니면, 에러를 직접 발생시킵니다.
      // 이 에러는 함수 밖으로 전달되어 .catch()에서 잡을 수 있습니다.
      throw new Error(response.status);
    }

    // 함수를 호출하고, .catch()를 사용해 에러를 처리합니다.
    // 이렇게 하면 loadJson 함수는 데이터 로딩에만 집중하고,
    // 에러 처리는 호출하는 쪽에서 자유롭게 결정할 수 있습니다.
    loadJson("no-such-user.json").catch((err) => {
      console.error("에러가 발생했습니다:", err); // 예: 에러가 발생했습니다: Error: 404
    });
  </script>
</body>
