<head>
  <title>arrow-function</title>
  <style>
    pre {
      /* 2. '프리텐다드'를 가장 먼저 사용하도록 설정합니다. */
      font-family: "Pretendard", -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size: 16px; /* 기본 폰트 크기를 살짝 키워 가독성을 높입니다. */
      line-height: 1.6; /* 줄 간격을 넓혀서 덜 답답하게 만듭니다. */
      background-color: #f7f7f7; /* 아주 연한 회색 배경을 추가해 영역을 구분합니다. */
      padding: 1em; /* 안쪽 여백을 줍니다. */
      border-radius: 8px; /* 모서리를 둥글게 만듭니다. */
    }
    .red {
      color: red;
      font-weight: bold;
    }
    .ml-1 {
      margin-left: 1em;
    }
  </style>
  <!-- 1. Prism.js의 CSS 파일을 불러옵니다 (기본 밝은 테마) -->
  <link
    href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css"
    rel="stylesheet"
  />
</head>

<body>
  <h3 style="color: rgb(172, 172, 172)">arrow-function</h3>
  <div>
    <details>
      <summary>화살표함수와 일반함수의 차이점- 1.___를 가지지 않는다.</summary>
      <pre>this</pre>
    </details>
    <details>
      <summary>
        2.인수에 접근할수있는게 없다. 즉 유사배열객체인 a________가 없다.
      </summary>
      <pre>arguments</pre>
    </details>
    <details>
      <summary>n _ _와 함께 호출생성할수없다 (this도 없기 때문)</summary>
      <pre>new</pre>
    </details>
    <details>
      <summary>
        super도 없다!<br />화살표 함수와 super의 관계는 클래스 상속 챕터에서
        학습할 예정
      </summary>
      <pre></pre>
    </details>
    <details>
      <summary>.bind(this)는 함수의 '_____버전'을 만듭니다.</summary>
      <pre>한정된 버전(bound version)</pre>
    </details>
    <details>
      <summary>화살표함수는 어떤 것도 b___시키지않는다.</summary>
      <pre>
bind 바인딩, 화살표함수에서 만약 this를 사용하면 외부 렉시컬환경에서 찾는다고 함 </pre
      >
    </details>
    <details>
      <summary>
        정리하자면 arguments를 사용하던 옛날엔."화살표함수가 의존적"이지만
        <br />
        <span class="red ml-1">요즘엔</span> 나머지매개변수(...args)가 등장하여
        화살표함수도 __적으로 사용할 수 있게 되었다.
      </summary>
      <pre>독립적</pre>
    </details>
  </div>

  <script>
    //🍎화살표 함수에는 'this’가 없습니다
    let group = {
      title: "1모둠",
      names: ["보라", "호진", "지민"],
      showList() {
        this.names.forEach((name) => console.log(this.title + ":" + name));
      }, // 화살표함수는 this가 존재하지 않으므로 에러도 발생하지 않고 바깥에 해당하는 this들을 쓴다.
      //만약 화살표함수가 아니라 일반함수를 사용했으면 에러가 발생했을 것. (this는 undefined title에 접근했을 것이다. )
    };

    group.showList();

    //🍎화살표 함수엔 'arguments’가 없습니다
    //🚩일반함수에는 argu가 있다.
    function normal(a, b) {
      console.log("일반함수의 arguments: ", arguments);
      //argument는 JS가 일반함수 안에 자동으로 만들어주는 특별한변수이다.
    }
    normal("야", "호", "코", "코"); //{0: "야",1: "호,"2: "코",3: "코"} 유사배열객체를 가짐

    //🍎화살표 함수는 arguments가 없다.
    // let arrow = (a, b) => {
    //   console.log("화살표함수의 arguments: ", arguments);
    // };
    // arrow("야", "호", "코", "코"); //error 발생: Uncaught ReferenceError: arguments is not defined at arrow

    //🍎그러므로 화살표함수 arguments를 사용하고 싶으면 바깥함수를 만들어줘서
    //바깥함수의 arguments를 사용하도록 해줘야한다.
    //아이같이 의존적인 녀석 (정확히표현하자면 간결성을 위해 만들어진 용도라서 기능이 제한적인 부분이 있다.)
    function outer(a) {
      let arrow = () => {
        console.log("화살표함수바로바깥의 arguments: ", arguments);
      };
      arrow("읭", "뭥미");
    }
    outer("밖에서", "준", "값이지롱"); //{ '0': '밖에서', '1': '준', '2': '값' }

    //🍎화살표 함수에서 인수를 다루는 현대적인 방법: 나머지 매개변수 (...args)
    // '...args'는 신문법(ES6)이 맞으며, arguments 객체를 대체하는 더 좋은 방법입니다.
    // 진짜 배열이기 때문에 map, filter 등 배열 메서드를 바로 사용할 수 있습니다.
    let arrowArgs = (...args) => {
      console.log("화살표함수args: ", args);
    };
    arrowArgs("에이", "알", "쥐", "에스"); // ["에이", "알", "쥐", "에스"] -> 진짜 배열이 출력됩니다.
  </script>
</body>
